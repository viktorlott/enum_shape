use std::{ops::Deref, str::FromStr};

use proc_macro2::Ident;
use syn::{parse_str, ItemTrait};

#[derive(Debug)]
pub enum StandardTrait {
    AbcTrait,
    Any,
    Borrow,
    BorrowMut,
    Eq,
    AsMut,
    AsRef,
    From,
    Into,
    TryFrom,
    TryInto,
    Default,
    Binary,
    Debug,
    Display,
    LowerExp,
    LowerHex,
    Octal,
    Pointer,
    UpperExp,
    UpperHex,
    Future,
    IntoFuture,
    FromIterator,
    FusedIterator,
    IntoIterator,
    Product,
    Sum,
    Copy,
    Sized,
    ToSocketAddrs,
    Add,
    AddAssign,
    BitAnd,
    BitAndAssign,
    BitOr,
    BitOrAssign,
    BitXor,
    BitXorAssign,
    Deref,
    DerefMut,
    Div,
    DivAssign,
    Drop,
    Fn,
    FnMut,
    FnOnce,
    Index,
    IndexMut,
    Mul,
    MulAssign,
    MultiMethod,
    Neg,
    Not,
    Rem,
    RemAssign,
    Shl,
    ShlAssign,
    Shr,
    ShrAssign,
    Sub,
    SubAssign,
    Termination,
    SliceIndex,
    FromStr,
    ToString,
}

#[repr(transparent)]
#[derive(Clone, Hash, Debug)]
pub struct TraitSchematic(pub ItemTrait);

impl From<StandardTrait> for TraitSchematic {
    fn from(value: StandardTrait) -> Self {
        TraitSchematic(
            match value {
                StandardTrait::AbcTrait => parse_str(include_str!("./AbcTrait.rs")),
                StandardTrait::Any => parse_str(include_str!("./Any.rs")),
                StandardTrait::Borrow => parse_str(include_str!("./Borrow.rs")),
                StandardTrait::BorrowMut => parse_str(include_str!("./BorrowMut.rs")),
                StandardTrait::Eq => parse_str(include_str!("./Eq.rs")),
                StandardTrait::AsMut => parse_str(include_str!("./AsMut.rs")),
                StandardTrait::AsRef => parse_str(include_str!("./AsRef.rs")),
                StandardTrait::From => parse_str(include_str!("./From.rs")),
                StandardTrait::Into => parse_str(include_str!("./Into.rs")),
                StandardTrait::TryFrom => parse_str(include_str!("./TryFrom.rs")),
                StandardTrait::TryInto => parse_str(include_str!("./TryInto.rs")),
                StandardTrait::Default => parse_str(include_str!("./Default.rs")),
                StandardTrait::Binary => parse_str(include_str!("./Binary.rs")),
                StandardTrait::Debug => parse_str(include_str!("./Debug.rs")),
                StandardTrait::Display => parse_str(include_str!("./Display.rs")),
                StandardTrait::LowerExp => parse_str(include_str!("./LowerExp.rs")),
                StandardTrait::LowerHex => parse_str(include_str!("./LowerHex.rs")),
                StandardTrait::Octal => parse_str(include_str!("./Octal.rs")),
                StandardTrait::Pointer => parse_str(include_str!("./Pointer.rs")),
                StandardTrait::UpperExp => parse_str(include_str!("./UpperExp.rs")),
                StandardTrait::UpperHex => parse_str(include_str!("./UpperHex.rs")),
                StandardTrait::Future => parse_str(include_str!("./Future.rs")),
                StandardTrait::IntoFuture => parse_str(include_str!("./IntoFuture.rs")),
                StandardTrait::FromIterator => parse_str(include_str!("./FromIterator.rs")),
                StandardTrait::FusedIterator => parse_str(include_str!("./FusedIterator.rs")),
                StandardTrait::IntoIterator => parse_str(include_str!("./IntoIterator.rs")),
                StandardTrait::Product => parse_str(include_str!("./Product.rs")),
                StandardTrait::Sum => parse_str(include_str!("./Sum.rs")),
                StandardTrait::Copy => parse_str(include_str!("./Copy.rs")),
                StandardTrait::Sized => parse_str(include_str!("./Sized.rs")),
                StandardTrait::ToSocketAddrs => parse_str(include_str!("./ToSocketAddrs.rs")),
                StandardTrait::Add => parse_str(include_str!("./Add.rs")),
                StandardTrait::AddAssign => parse_str(include_str!("./AddAssign.rs")),
                StandardTrait::BitAnd => parse_str(include_str!("./BitAnd.rs")),
                StandardTrait::BitAndAssign => parse_str(include_str!("./BitAndAssign.rs")),
                StandardTrait::BitOr => parse_str(include_str!("./BitOr.rs")),
                StandardTrait::BitOrAssign => parse_str(include_str!("./BitOrAssign.rs")),
                StandardTrait::BitXor => parse_str(include_str!("./BitXor.rs")),
                StandardTrait::BitXorAssign => parse_str(include_str!("./BitXorAssign.rs")),
                StandardTrait::Deref => parse_str(include_str!("./Deref.rs")),
                StandardTrait::DerefMut => parse_str(include_str!("./DerefMut.rs")),
                StandardTrait::Div => parse_str(include_str!("./Div.rs")),
                StandardTrait::DivAssign => parse_str(include_str!("./DivAssign.rs")),
                StandardTrait::Drop => parse_str(include_str!("./Drop.rs")),
                StandardTrait::Fn => parse_str(include_str!("./Fn.rs")),
                StandardTrait::FnMut => parse_str(include_str!("./FnMut.rs")),
                StandardTrait::FnOnce => parse_str(include_str!("./FnOnce.rs")),
                StandardTrait::Index => parse_str(include_str!("./Index.rs")),
                StandardTrait::IndexMut => parse_str(include_str!("./IndexMut.rs")),
                StandardTrait::Mul => parse_str(include_str!("./Mul.rs")),
                StandardTrait::MulAssign => parse_str(include_str!("./MulAssign.rs")),
                StandardTrait::MultiMethod => parse_str(include_str!("./MultiMethod.rs")),
                StandardTrait::Neg => parse_str(include_str!("./Neg.rs")),
                StandardTrait::Not => parse_str(include_str!("./Not.rs")),
                StandardTrait::Rem => parse_str(include_str!("./Rem.rs")),
                StandardTrait::RemAssign => parse_str(include_str!("./RemAssign.rs")),
                StandardTrait::Shl => parse_str(include_str!("./Shl.rs")),
                StandardTrait::ShlAssign => parse_str(include_str!("./ShlAssign.rs")),
                StandardTrait::Shr => parse_str(include_str!("./Shr.rs")),
                StandardTrait::ShrAssign => parse_str(include_str!("./ShrAssign.rs")),
                StandardTrait::Sub => parse_str(include_str!("./Sub.rs")),
                StandardTrait::SubAssign => parse_str(include_str!("./SubAssign.rs")),
                StandardTrait::Termination => parse_str(include_str!("./Termination.rs")),
                StandardTrait::SliceIndex => parse_str(include_str!("./SliceIndex.rs")),
                StandardTrait::FromStr => parse_str(include_str!("./FromStr.rs")),
                StandardTrait::ToString => parse_str(include_str!("./ToString.rs")),
            }
            .expect("Std trait file should exist"),
        )
    }
}

impl FromStr for StandardTrait {
    type Err = ();
    fn from_str(value: &str) -> Result<Self, ()> {
        Ok(match value {
            "AbcTrait" => Self::AbcTrait,
            "Any" => Self::Any,
            "Borrow" => Self::Borrow,
            "BorrowMut" => Self::BorrowMut,
            "Eq" => Self::Eq,
            "AsMut" => Self::AsMut,
            "AsRef" => Self::AsRef,
            "From" => Self::From,
            "Into" => Self::Into,
            "TryFrom" => Self::TryFrom,
            "TryInto" => Self::TryInto,
            "Default" => Self::Default,
            "Binary" => Self::Binary,
            "Debug" => Self::Debug,
            "Display" => Self::Display,
            "LowerExp" => Self::LowerExp,
            "LowerHex" => Self::LowerHex,
            "Octal" => Self::Octal,
            "Pointer" => Self::Pointer,
            "UpperExp" => Self::UpperExp,
            "UpperHex" => Self::UpperHex,
            "Future" => Self::Future,
            "IntoFuture" => Self::IntoFuture,
            "FromIterator" => Self::FromIterator,
            "FusedIterator" => Self::FusedIterator,
            "IntoIterator" => Self::IntoIterator,
            "Product" => Self::Product,
            "Sum" => Self::Sum,
            "Copy" => Self::Copy,
            "Sized" => Self::Sized,
            "ToSocketAddrs" => Self::ToSocketAddrs,
            "Add" => Self::Add,
            "AddAssign" => Self::AddAssign,
            "BitAnd" => Self::BitAnd,
            "BitAndAssign" => Self::BitAndAssign,
            "BitOr" => Self::BitOr,
            "BitOrAssign" => Self::BitOrAssign,
            "BitXor" => Self::BitXor,
            "BitXorAssign" => Self::BitXorAssign,
            "Deref" => Self::Deref,
            "DerefMut" => Self::DerefMut,
            "Div" => Self::Div,
            "DivAssign" => Self::DivAssign,
            "Drop" => Self::Drop,
            "Fn" => Self::Fn,
            "FnMut" => Self::FnMut,
            "FnOnce" => Self::FnOnce,
            "Index" => Self::Index,
            "IndexMut" => Self::IndexMut,
            "Mul" => Self::Mul,
            "MulAssign" => Self::MulAssign,
            "MultiMethod" => Self::MultiMethod,
            "Neg" => Self::Neg,
            "Not" => Self::Not,
            "Rem" => Self::Rem,
            "RemAssign" => Self::RemAssign,
            "Shl" => Self::Shl,
            "ShlAssign" => Self::ShlAssign,
            "Shr" => Self::Shr,
            "ShrAssign" => Self::ShrAssign,
            "Sub" => Self::Sub,
            "SubAssign" => Self::SubAssign,
            "Termination" => Self::Termination,
            "SliceIndex" => Self::SliceIndex,
            "FromStr" => Self::FromStr,
            "ToString" => Self::ToString,
            _ => panic!("no match found, {}", value),
        })
    }
}
impl From<&Ident> for StandardTrait {
    fn from(value: &Ident) -> Self {
        StandardTrait::from_str(value.to_string().as_str()).expect("Expect to find a match")
    }
}

impl Deref for TraitSchematic {
    type Target = ItemTrait;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
